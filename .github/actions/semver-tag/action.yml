name: Semver Tag
description: Compute next semantic version from PR context, create and push a git tag, and output tag and version.

outputs:
  new_tag:
    description: New tag in the format vX.Y.Z
    value: ${{ steps.bump.outputs.new_tag }}
  version:
    description: Version without leading v (X.Y.Z)
    value: ${{ steps.ver.outputs.version }}

runs:
  using: composite
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Fetch tags
      shell: bash
      run: git fetch --tags --force --prune

    - name: Determine latest tag vX.Y.Z
      id: latest
      shell: bash
      run: |
        LATEST="$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-version:refname | head -n1)"
        if [ -z "$LATEST" ]; then LATEST="v0.0.0"; fi
        echo "latest=$LATEST" >> "$GITHUB_OUTPUT"

    - name: Compute next version
      id: bump
      shell: bash
      env:
        BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
        HEAD_BRANCH: ${{ github.event.pull_request.head.ref }}
        MERGE_SHA: ${{ github.event.pull_request.merge_commit_sha }}
        PR_TITLE: ${{ github.event.pull_request.title }}
        HAS_MAJOR_LABEL: ${{ contains(github.event.pull_request.labels.*.name, 'semver:major') }}
      run: |
        set -euo pipefail
        LATEST="${{ steps.latest.outputs.latest }}"
        if [[ ! "$LATEST" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
          echo "Malformed latest tag" >&2
          exit 1
        fi
        X="${BASH_REMATCH[1]}"; Y="${BASH_REMATCH[2]}"; Z="${BASH_REMATCH[3]}"

        HEAD_BRANCH="${HEAD_BRANCH:-}"
        PR_TITLE="${PR_TITLE:-}"
        HAS_MAJOR_LABEL="${HAS_MAJOR_LABEL:-false}"

        if [ "$HAS_MAJOR_LABEL" = "true" ] || [[ "$PR_TITLE" =~ (\[major\]|#major) ]]; then
          X=$((X+1)); Y=0; Z=0; REASON="major signal"
        elif [[ "$HEAD_BRANCH" =~ ^hotfix/ ]]; then
          Z=$((Z+1)); REASON="hotfix patch bump"
        else
          Y=$((Y+1)); Z=0; REASON="regular release minor bump"
        fi

        NEW_TAG="v${X}.${Y}.${Z}"
        echo "new_tag=$NEW_TAG" >> "$GITHUB_OUTPUT"
        echo "reason=$REASON"

    - name: Configure git user for tagging
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

    - name: Tag merge commit
      shell: bash
      env:
        BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
        MERGE_SHA: ${{ github.event.pull_request.merge_commit_sha }}
      run: |
        NEW_TAG="${{ steps.bump.outputs.new_tag }}"
        MERGE_SHA="${MERGE_SHA}"

        if git rev-parse -q --verify "refs/tags/$NEW_TAG" >/dev/null; then
          echo "Tag $NEW_TAG already exists" >&2
          exit 1
        fi

        if [ -z "$MERGE_SHA" ] || ! git cat-file -e "$MERGE_SHA^{commit}" 2>/dev/null; then
          echo "merge_commit_sha not available, fallback to latest on base branch"
          git fetch origin "$BASE_BRANCH":"refs/remotes/origin/$BASE_BRANCH"
          MERGE_SHA="$(git rev-parse "origin/$BASE_BRANCH")"
        fi

        echo "Tagging $MERGE_SHA with $NEW_TAG"
        git tag -a "$NEW_TAG" "$MERGE_SHA" -m "chore(release): $NEW_TAG"
        git push origin "$NEW_TAG"

    - name: Derive version without v
      id: ver
      shell: bash
      run: |
        TAG="${{ steps.bump.outputs.new_tag }}"
        echo "version=${TAG#v}" >> "$GITHUB_OUTPUT"
